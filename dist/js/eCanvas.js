/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/EArc.js":
/*!************************!*\
  !*** ./src/js/EArc.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MoveShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MoveShape */ \"./src/js/MoveShape.js\");\n\r\n/**可控圆形EArc\r\n * \r\n * \r\n */\r\nclass EArc extends _MoveShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(x, y, radius, startAngle, endAngle, anticlockwise, style = 'fill', color = '#000') {\r\n    super()\r\n    //基本信息\r\n    this.x = x\r\n    this.y = y\r\n    this.radius = radius\r\n    this.startAngle = startAngle\r\n    this.endAngle = endAngle\r\n    this.anticlockwise = anticlockwise\r\n    this.style = style\r\n    this.color = color\r\n    this.ctx = null\r\n    //碰撞信息\r\n    this.hitType = 'Arc'\r\n    //名称\r\n    this.name = 'unnamed-EArc'\r\n\r\n    //绘画\r\n    this.beforDrow\r\n  }\r\n\r\n  draw(beforeDrow) {\r\n    if (typeof beforeDrow === 'function') {\r\n      beforeDrow()\r\n    }\r\n    this.ctx.beginPath()\r\n    this.ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise)\r\n    if (this.style === 'fill') {\r\n      this.ctx.fillStyle = this.color\r\n      this.ctx.fill()\r\n    } else if (this.style === 'stroke') {\r\n      this.ctx.strokeStyle = this.color\r\n      this.ctx.stroke()\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (EArc);\n\n//# sourceURL=webpack:///./src/js/EArc.js?");

/***/ }),

/***/ "./src/js/ECanvas.js":
/*!***************************!*\
  !*** ./src/js/ECanvas.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**eCanvas 入口类\r\n * eCanvas 入口类\r\n *  属性：\r\n *    canvas：DOM 树中的 canvas 元素\r\n *    w:canvas的宽度\r\n *    h:canvas的高度\r\n *    ctx：canvas 对应的上下文对象\r\n *    element：canvas 索要渲染的所有对象\r\n *    timeId: ECanvas 下所有定时器的 ID\r\n *    rafID：ECanvas 下所有请求动画关键帧的ID\r\n * \r\n *  */\r\nclass ECanvas {\r\n  constructor(canvas) {\r\n    this.canvas = canvas\r\n    this.w = 0\r\n    this.h = 0\r\n    this.ctx = null\r\n    this.elements = [\r\n      [],\r\n      [],\r\n      []\r\n    ]\r\n    this.timeId = []\r\n    this.rafId = []\r\n    this.event = {\r\n      click: [],\r\n      keydown: [],\r\n      keyup: [],\r\n      mousedown: [],\r\n      mousemove: [],\r\n      mouseup: [],\r\n    }\r\n    this.eventType = {}\r\n    this.bind = true\r\n\r\n    this.name = 'ECanvas'\r\n\r\n    this.init()\r\n  }\r\n\r\n  init() {\r\n    //绑定 w\r\n    Object.defineProperty(this, 'w', {\r\n      set: function (value) {\r\n        this.canvas.width = value\r\n      },\r\n      get: function () {\r\n        return this.canvas.width\r\n      }\r\n    })\r\n\r\n    //绑定 h\r\n    Object.defineProperty(this, 'h', {\r\n      set: function (value) {\r\n        this.canvas.height = value\r\n      },\r\n      get: function () {\r\n        return this.canvas.height\r\n      }\r\n    })\r\n\r\n    //获取上下文对象\r\n    if (this.canvas.getContext) {\r\n      this.ctx = this.canvas.getContext('2d')\r\n    } else {\r\n      console.error('您的浏览器不支持 \"<canvas>\" 标签')\r\n    }\r\n\r\n    this.doEvent()\r\n  }\r\n\r\n  //向画布中挂载对象\r\n  toBind(ele) {\r\n    if (ele && !ele.bind) {\r\n      ele.ctx = this.ctx\r\n      ele.bind = this\r\n      this.elements[ele.zIndex].push(ele)\r\n    }\r\n\r\n  }\r\n\r\n  //添加事件元素\r\n  bindEvent(ele) {\r\n    for (let event in ele.eventType) {\r\n      if (this.event[event].indexOf(ele) === -1) {\r\n        this.event[event].push(ele)\r\n      }\r\n    }\r\n  }\r\n\r\n  //移出事件绑定\r\n  removeEvent() {}\r\n\r\n  //解除挂载\r\n  removeBind(ele) {\r\n    ele.stop()\r\n    if (ele) {\r\n      ele.ctx = null\r\n      ele.bind = false\r\n      console.log('remove')\r\n    } else {\r\n      console.warn(ele + '对象不存在');\r\n    }\r\n  }\r\n\r\n  //执行事件代理 \r\n  doEvent() {\r\n    //创建鼠标事件的方法\r\n    let createMouseEvent = (type, e) => {\r\n      for (let i = 0; i < this.event[type].length; i++) {\r\n        if (!this.event[type][i].bind) {\r\n          this.event[type].splice(i, 1)\r\n          i--\r\n          continue\r\n        }\r\n        //创建点击事件的事件对象\r\n        let event = new MouseEvent(type, e, this, i);\r\n        //判断是否触发事件\r\n        if (this.event[type][i] instanceof ECanvas) {\r\n          for (let fn in this.eventType[type]) {\r\n            if (this.eventType[type][fn]) {\r\n              event.eventName = fn\r\n              this.eventType[type][fn].call(this, event)\r\n            }\r\n          }\r\n        } else if (pointInShape([event.canvasX, event.canvasY], this.event[type][i])) {\r\n          for (let fn in event.shape.eventType[type]) {\r\n            if (event.shape.eventType[type][fn]) {\r\n              event.eventName = fn\r\n              event.shape.eventType[type][fn].call(event.shape, event)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //注册鼠标相关事件\r\n    //鼠标点击事件\r\n    this.canvas.addEventListener('click', (e) => {\r\n      createMouseEvent('click', e)\r\n    })\r\n    //鼠标按下事件\r\n    this.canvas.addEventListener('mousedown', (e) => {\r\n      createMouseEvent('mousedown', e)\r\n    })\r\n    //鼠标抬起事件\r\n    this.canvas.addEventListener('mouseup', (e) => {\r\n      createMouseEvent('mouseup', e)\r\n    })\r\n    //鼠标移动事件\r\n    this.canvas.addEventListener('mousemove', (e) => {\r\n      createMouseEvent('mousemove', e)\r\n    })\r\n\r\n    //创建键盘相关事件的方法\r\n    let createKeyEvent = (type, e) => {\r\n      for (let i = 0; i < this.event[type].length; i++) {\r\n        let event = new KeyEvent(type, e, this, i)\r\n        for (let fn in event.shape.eventType[type]) {\r\n          if (event.shape.eventType[type][fn]) {\r\n            event.eventName = fn\r\n            event.shape.eventType[type][fn].call(event.shape, event)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //注册键盘相关事件\r\n    //键盘按下事件\r\n    window.addEventListener('keydown', (e) => {\r\n      createKeyEvent('keydown', e)\r\n    })\r\n    //键盘抬起事件\r\n    window.addEventListener('keyup', (e) => {\r\n      createKeyEvent('keyup', e)\r\n    })\r\n  }\r\n\r\n  //预删除\r\n  preRemoveBind(arr, removeFun, clearFun) {\r\n    let id = setInterval(() => {\r\n      for (let i = 0; i < arr.length; i++) {\r\n        if (removeFun(arr[i])) {\r\n          this.removeBind(arr[i])\r\n          arr.splice(i, 1)\r\n          i--\r\n          continue\r\n        }\r\n        if (typeof clearFun === 'function') {\r\n          if (clearFun()) {\r\n            clearInterval(id)\r\n          }\r\n        }\r\n      }\r\n    }, 10)\r\n    if (!clearFun) {\r\n      console.warn('如果不及时清理元素集预删除(preRemoveBind)时所产生的定时器，可能会造成资源浪费哦,建议添加clearFun方法自动清理(推荐)或者通过定时器(clearInterval)id手动清理,添加true参数可以关闭提示')\r\n    }\r\n    return id\r\n  }\r\n\r\n  //添加事件\r\n  addEventListener(type, name, callback) {\r\n    if (this.eventType[type] === undefined) {\r\n      this.eventType[type] = {}\r\n      this.eventType[type][name] = callback\r\n    } else {\r\n      this.eventType[type][name] = callback\r\n    }\r\n    this.bindEvent(this)\r\n  }\r\n\r\n  //移出事件\r\n  removeEventListener(type, name) {\r\n    this.eventType[type][name] = undefined\r\n  }\r\n  // 页面渲染入口\r\n  draw(callback) {\r\n    let rafId\r\n    let animate = () => {\r\n      this.ctx.clearRect(0, 0, this.w, this.h)\r\n      for (let i = 0; i < this.elements.length; i++) {\r\n        for (let j = 0; j < this.elements[i].length; j++) {\r\n          if (!this.elements[i][j].bind) {\r\n            this.elements[i].splice(j, 1)\r\n            j--\r\n            continue\r\n          }\r\n          this.elements[i][j].draw()\r\n        }\r\n      }\r\n      window.requestAnimationFrame(animate)\r\n    }\r\n    animate()\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ECanvas);\n\n//# sourceURL=webpack:///./src/js/ECanvas.js?");

/***/ }),

/***/ "./src/js/ERect.js":
/*!*************************!*\
  !*** ./src/js/ERect.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MoveShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MoveShape */ \"./src/js/MoveShape.js\");\n\r\n\r\n/**可控矩形ERect\r\n * 属性：\r\n *  x：矩形左上角x坐标\r\n *  y：矩形左上角y坐标\r\n *  w：矩形宽度\r\n *  h：矩形高度\r\n *  shape：矩形实心（fill）或者空心（stroke）\r\n *  color：矩形颜色\r\n */\r\nclass ERect extends _MoveShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(x, y, width, height, style = 'fill', color = '#000') {\r\n    super()\r\n    //rect 基础属性\r\n    this.x = x\r\n    this.y = y\r\n    this.width = width\r\n    this.height = height\r\n    this.color = color\r\n    this.ctx = null\r\n    this.style = style\r\n\r\n    //位置信息\r\n    this.pointO\r\n    this.pointX\r\n    this.pointY\r\n    this.pointXY\r\n    this.matrix\r\n    this.pointM\r\n    this.direction = 0\r\n\r\n    //碰撞信息\r\n    this.hitType\r\n\r\n    //命名\r\n    this.name = 'unnamed-ERect'\r\n\r\n    //图片信息\r\n    this.Image = new Image()\r\n    this.imgIsLoad = false\r\n    this.img\r\n    this.imgs = []\r\n\r\n    this.init()\r\n\r\n  }\r\n  //初始化信息\r\n  init() {\r\n    this.pointM = 'leftTop'\r\n    this.setPoints()\r\n\r\n    Object.defineProperty(this, 'hitType', {\r\n      get: function () {\r\n        return this.direction % Math.PI / 2 === 0 ? 'AABB' : 'Rect'\r\n      }\r\n    })\r\n  }\r\n\r\n  //同步位置信息\r\n  setPoints() {\r\n    Object.defineProperty(this, 'matrix', {\r\n      get: function () {\r\n        switch (this.pointM) {\r\n          case 'middle':\r\n            return this.matrix = [\r\n              [-this.width / 2 * Math.cos(this.direction), -this.width / 2 * Math.sin(this.direction),\r\n                this\r\n                .x\r\n              ],\r\n              [-this.height / 2 * Math.sin(this.direction), -this.height / 2 * Math.cos(this.direction),\r\n                this\r\n                .y\r\n              ],\r\n              [0, 0, this.direction]\r\n            ]\r\n          case 'leftTop':\r\n            return this.matrix = [\r\n              [this.width * Math.cos(this.direction), this.width * Math.sin(this.direction), this.x],\r\n              [-this.height * Math.sin(this.direction), this.height * Math.cos(this.direction), this.y],\r\n              [0, 0, this.direction]\r\n            ]\r\n          case 'rightTop':\r\n            return this.matrix = [\r\n              [(-this.width) * Math.cos(this.direction), (-this.width) * Math.sin(this.direction), this\r\n                .x\r\n              ],\r\n              [-this.height * Math.sin(this.direction), this.height * Math.cos(this.direction), this.y],\r\n              [0, 0, this.direction]\r\n            ]\r\n          case 'leftBottom':\r\n            return this.matrix = [\r\n              [this.width * Math.cos(this.direction), this.width * Math.sin(this.direction), this.x],\r\n              [this.height * Math.sin(this.direction), -this.height * Math.cos(this.direction), this.y],\r\n              [0, 0, this.direction]\r\n            ]\r\n          case 'rightBottom':\r\n            return this.matrix = [\r\n              [-this.width * Math.cos(this.direction), -this.width * Math.sin(this.direction), this.x],\r\n              [this.height * Math.sin(this.direction), -this.height * Math.cos(this.direction), this.y],\r\n              [0, 0, this.direction]\r\n            ]\r\n        }\r\n      },\r\n      set: function () {\r\n\r\n      }\r\n    })\r\n    Object.defineProperty(this, 'pointO', {\r\n      get: function () {\r\n        switch (this.pointM) {\r\n          case 'middle':\r\n            return [(-this.width / 2) * Math.cos(this.direction) - (-this.height / 2) * Math.sin(this\r\n                .direction) + this.x, (-this.width / 2) * Math.sin(this.direction) + (-this.height / 2) *\r\n              Math\r\n              .cos(this\r\n                .direction) + this.y\r\n            ]\r\n          case 'leftTop':\r\n            return [this.x, this.y]\r\n          case 'rightTop':\r\n            return [this.matrix[0][0] + this.x + this.width, this.matrix[0][1] + this.y]\r\n          case 'leftBottom':\r\n            return [this.matrix[1][0] + this.x, this.matrix[1][1] + this.y + this.height]\r\n          case 'rightBottom':\r\n            return [-this.width * Math.cos(this.direction) + this.height * Math.sin(this.direction) + this\r\n              .x +\r\n              this.width,\r\n              -this.height * Math.cos(this.direction) - this.width * Math.sin(this.direction) + this.y +\r\n              this\r\n              .height\r\n            ]\r\n        }\r\n      }\r\n    })\r\n    Object.defineProperty(this, 'pointX', {\r\n      get: function () {\r\n        switch (this.pointM) {\r\n          case 'middle':\r\n            return [(this.width / 2) * Math.cos(this.direction) - (-this.height / 2) * Math.sin(this\r\n                .direction) + this.x,\r\n              (this.width / 2) * Math.sin(this.direction) + (-this.height / 2) * Math.cos(this\r\n                .direction) +\r\n              this.y\r\n            ]\r\n          case 'leftTop':\r\n            return [this.matrix[0][0] + this.x, this.matrix[0][1] + this.y]\r\n          case 'rightTop':\r\n            return [this.width + this.x, this.y]\r\n          case 'leftBottom':\r\n            return [this.width * Math.cos(this.direction) + this.height * Math.sin(this.direction) + this.x,\r\n              -this.height * Math.cos(this.direction) + this.width * Math.sin(this.direction) + this.y +\r\n              this\r\n              .height\r\n            ]\r\n          case 'rightBottom':\r\n            return [this.matrix[1][0] + this.x + this.width, this.matrix[1][1] + this.y + this.height]\r\n        }\r\n\r\n      }\r\n    })\r\n    Object.defineProperty(this, 'pointY', {\r\n      get: function () {\r\n        switch (this.pointM) {\r\n          case 'middle':\r\n            return [(-this.width / 2) * Math.cos(this.direction) - (this.height / 2) * Math.sin(this\r\n                .direction) + this.x,\r\n              (-this.width / 2) * Math.sin(this.direction) + (this.height / 2) * Math.cos(this\r\n                .direction) +\r\n              this.y\r\n            ]\r\n          case 'leftTop':\r\n            return [this.matrix[1][0] + this.x, this.matrix[1][1] + this.y]\r\n          case 'rightTop':\r\n            return [-this.width * Math.cos(this.direction) - this.height * Math.sin(this.direction) + this\r\n              .x +\r\n              this.width,\r\n              this.height * Math.cos(this.direction) + (-this.width) * Math.sin(this.direction) + this.y\r\n            ]\r\n          case 'leftBottom':\r\n            return [this.x, this.y + this.height]\r\n          case 'rightBottom':\r\n            return [this.matrix[0][0] + this.x + this.width, this.matrix[0][1] + this.y + this.height]\r\n        }\r\n      }\r\n    })\r\n    Object.defineProperty(this, 'pointXY', {\r\n      get: function () {\r\n        switch (this.pointM) {\r\n          case 'middle':\r\n            return [(this.width / 2) * Math.cos(this.direction) - (this.height / 2) * Math.sin(this\r\n                .direction) +\r\n              this.x,\r\n              (this.width / 2) * Math.sin(this.direction) + (this.height / 2) * Math.cos(this.direction) +\r\n              this.y\r\n            ]\r\n          case 'leftTop':\r\n            return [this.width * Math.cos(this.direction) - this.height * Math.sin(this.direction) + this.x,\r\n              this.height * Math.cos(this.direction) + this.width * Math.sin(this.direction) + this.y\r\n            ]\r\n          case 'rightTop':\r\n            return [this.matrix[1][0] + this.x + this.width, this.matrix[1][1] + this.y]\r\n          case 'leftBottom':\r\n            return [this.matrix[0][0] + this.x, this.matrix[0][1] + this.y + this.height]\r\n          case 'rightBottom':\r\n            return [this.x + this.width, this.y + this.height]\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  //控制旋转的方法 \r\n  rotate(direction, pointM = 'middle') {\r\n    this.direction = direction\r\n    this.pointM = pointM\r\n  }\r\n\r\n  //设置图片的方法 \r\n  initImage(imgs) {\r\n    this.imgs = imgs\r\n    let loadComplete = async (src) => {\r\n      return new Promise((resolve) => {\r\n        this.Image.src = src\r\n        this.Image.onload = () => {\r\n          // console.log(1)\r\n          // console.log('img load completed!' + src)\r\n          resolve('sucess')\r\n        }\r\n      })\r\n    }\r\n    let init = async () => {\r\n      // console.log(this)\r\n      let res = await Promise.all(this.imgs.map(src => {\r\n        loadComplete(src)\r\n      }))\r\n      // console.log(true)\r\n      this.imgIsLoad = true\r\n      this.img = this.imgs[0]\r\n    }\r\n    init()\r\n  }\r\n\r\n\r\n\r\n  //绘画的方法\r\n  draw(beforeDrow) {\r\n    if (typeof beforeDrow === 'function') {\r\n      beforeDrow()\r\n    }\r\n    if (this.imgIsLoad) {\r\n      this.ctx.translate(this.pointO[0], this.pointO[1])\r\n      this.ctx.rotate(this.direction)\r\n      this.ctx.drawImage(this.Image, 0, 0)\r\n      this.ctx.rotate(-this.direction)\r\n      this.ctx.translate(-this.pointO[0], -this.pointO[1])\r\n    }\r\n\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.pointO[0], this.pointO[1])\r\n    this.ctx.lineTo(this.pointX[0], this.pointX[1])\r\n    this.ctx.lineTo(this.pointXY[0], this.pointXY[1])\r\n    this.ctx.lineTo(this.pointY[0], this.pointY[1])\r\n    this.ctx.lineTo(this.pointO[0], this.pointO[1])\r\n    if (this.style === 'fill') {\r\n      this.ctx.fillStyle = this.color\r\n      this.ctx.fill()\r\n    } else if (this.style === 'stroke') {\r\n      this.ctx.strokeStyle = this.color\r\n      this.ctx.stroke()\r\n    }\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ERect);\n\n//# sourceURL=webpack:///./src/js/ERect.js?");

/***/ }),

/***/ "./src/js/Event.js":
/*!*************************!*\
  !*** ./src/js/Event.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// 事件对象\r\n\r\n/**\r\n * 鼠标相关的事件对象类\r\n */\r\nclass MouseEvent {\r\n  constructor(type, e, that, i) {\r\n    this.canvasX = e.clientX - that.canvas.getBoundingClientRect().left\r\n    this.canvasY = e.clientY - that.canvas.getBoundingClientRect().top\r\n    this.eventType = type\r\n    this.eventName = ''\r\n    this.shape = that.event[type][i]\r\n    this.shapeName = that.event[type][i].name\r\n    this.domEvent = e\r\n  }\r\n}\r\n\r\n/**\r\n * 键盘相关事件对象\r\n */\r\nclass KeyEvent {\r\n  constructor(type, e, that, i) {\r\n    this.key = e.key,\r\n      this.code = e.code,\r\n      this.keyCode = e.keyCode,\r\n      this.eventType = type,\r\n      this.eventName = '',\r\n      this.shapeName = that.event[type][i].name,\r\n      this.shape = that.event[type][i],\r\n      this.domEvent = e\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  KeyEvent,\r\n  MouseEvent\r\n});\n\n//# sourceURL=webpack:///./src/js/Event.js?");

/***/ }),

/***/ "./src/js/MoveShape.js":
/*!*****************************!*\
  !*** ./src/js/MoveShape.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**可控元素的父类\r\n * 可控元素的父类\r\n *   属性:\r\n    Mx: 元素的几何中心点  x 坐标\r\n    My: 元素的几何中心点  y 坐标\r\n    Vx: 元素沿 x 轴的速度\r\n    Vy：元素沿 y 轴的移动速度\r\n    Fx：元素沿 x 轴的受力\r\n    Fy：元素沿着 y 轴的受力\r\n    m： 元素的相对质量\r\n    bind: 是否已经挂在到 ECanvas 上\r\n * \r\n*/\r\nclass MoveShape {\r\n  constructor(Vx = 0, Vy = 0, Fx = 0, Fy = 0, m = 1) {\r\n    //元素运动信息\r\n    this.Vx = Vx\r\n    this.Vy = Vy\r\n    this.Fx = Fx\r\n    this.Fy = Fy\r\n    this.m = m\r\n\r\n    //元素定时器\r\n    this.timeId = []\r\n    this.rafId = []\r\n    //是否绑定在canvas画布上\r\n    this.bind = false\r\n\r\n    //层级信息\r\n    this.zIndex = 1\r\n\r\n    //事件信息\r\n    this.eventType = {}\r\n\r\n    //特征名称信息\r\n    this.name = 'unnamed-MoveShape'\r\n\r\n    //绘画的回调函数\r\n    this.beforeDrow\r\n\r\n    this.MoveShapeInit()\r\n  }\r\n\r\n  MoveShapeInit() {\r\n\r\n  }\r\n\r\n  //初始化运动属性\r\n  initMove(config) {\r\n    if (config) {\r\n      for (let key in config) {\r\n        this[key] = config[key]\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  //开始按照属性运动\r\n  move(callback) {\r\n    this.timeId.push(setInterval(() => {\r\n      this.Vx += this.Fx\r\n      this.Vy += this.Fy\r\n      this.x += this.Vx\r\n      this.y += this.Vy\r\n    }, 16))\r\n    if (callback) {\r\n      callback()\r\n    }\r\n  }\r\n\r\n  // 移动到指定的状态\r\n  moveTo(stopConfig, callback) {\r\n    this.move()\r\n    this.timeId.push(setInterval(() => {\r\n      for (let key in stopConfig) {\r\n        if (stopConfig[key] > this[key] - 2 * (this.Vx + this.Vy) && stopConfig[key] < this[key] + 2 * (this.Vx + this.Vy)) {\r\n          this[key] = stopConfig[key]\r\n          this.stop()\r\n          if (callback) {\r\n            callback();\r\n          }\r\n        }\r\n      }\r\n    }, 1))\r\n  }\r\n\r\n  //停止运动\r\n  stop(callback) {\r\n    for (let i = 0; i < this.timeId.length; i++) {\r\n      clearInterval(this.timeId[i])\r\n    }\r\n    for (let i = 0; i < this.rafId.length; i++) {\r\n      window.cancelAnimationFrame(this.rafId[i])\r\n    }\r\n    this.rafId = []\r\n    this.timeId = []\r\n    this.Vx = 0\r\n    this.Vy = 0\r\n    this.Fx = 0\r\n    this.Fy = 0\r\n    if (callback) {\r\n      callback()\r\n    }\r\n  }\r\n\r\n  //通过键盘上下左右运动\r\n  moveByKey(v = 3, key = ['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'], callback) {\r\n    if (callback) {\r\n      callback()\r\n    }\r\n    window.addEventListener('keydown', (e) => {\r\n      switch (e.key) {\r\n        case key[0]:\r\n          this.Vy = -v\r\n          break\r\n        case key[1]:\r\n          this.Vx = v\r\n          break\r\n        case key[2]:\r\n          this.Vy = v\r\n\r\n          break\r\n        case key[3]:\r\n          this.Vx = -v\r\n\r\n          break\r\n      }\r\n    })\r\n    window.addEventListener('keyup', (e) => {\r\n      switch (e.key) {\r\n        case 'ArrowUp':\r\n          this.Vy = 0\r\n          break\r\n        case 'ArrowDown':\r\n          this.Vy = 0\r\n          break\r\n        case 'ArrowLeft':\r\n          this.Vx = 0\r\n          break\r\n        case 'ArrowRight':\r\n          this.Vx = 0\r\n          break\r\n      }\r\n    })\r\n    this.move()\r\n  }\r\n\r\n  //添加事件\r\n  addEventListener(type, name, callback) {\r\n    if (this.bind === false) {\r\n      console.warn('请在添加事件前先将元素绑定到eCanvas对象上')\r\n    } else {\r\n      if (this.eventType[type] === undefined) {\r\n        this.eventType[type] = {}\r\n        this.eventType[type][name] = callback\r\n      } else {\r\n        this.eventType[type][name] = callback\r\n      }\r\n      this.bind.bindEvent(this)\r\n    }\r\n  }\r\n\r\n  //移出事件帮i的那个\r\n  removeEventListener(type, name) {\r\n    this.eventType[type][name] = undefined\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (MoveShape);\n\n//# sourceURL=webpack:///./src/js/MoveShape.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ECanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ECanvas.js */ \"./src/js/ECanvas.js\");\n/* harmony import */ var _MoveShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MoveShape.js */ \"./src/js/MoveShape.js\");\n/* harmony import */ var _ERect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ERect.js */ \"./src/js/ERect.js\");\n/* harmony import */ var _EArc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EArc.js */ \"./src/js/EArc.js\");\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Event.js */ \"./src/js/Event.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util.js */ \"./src/js/util.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet canvas = document.querySelector(' #canvas')\r\nlet eCanvas = new _ECanvas_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas)\r\nlet rect = new _ERect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](100, 100, 100, 100)\r\neCanvas.toBind(rect)\r\n\r\nlet rect2 = new _ERect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](100, 100, 100, 100, 'fill', 'red')\r\neCanvas.toBind(rect2)\r\nrect2.rotate(Math.PI / 4, 'leftTop')\r\n\r\n// rect.zIndexSet(2)\r\neCanvas.draw()\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ }),

/***/ "./src/js/util.js":
/*!************************!*\
  !*** ./src/js/util.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//公用方法\r\n//获取向量\r\nfunction getVector(point1, point2) {\r\n  return [point2[0] - point1[0], point2[1] - point1[1]]\r\n}\r\n//点乘向量\r\nfunction dot(vector1, vector2) {\r\n  return vector1[0] * vector2[0] + vector1[1] * vector2[1]\r\n}\r\n//叉乘向量\r\nfunction cross(vector1, vector2) {\r\n  return vector1[0] * vector2[1] - vector1[1] * vector2[0]\r\n}\r\n//图形判断位置的方法\r\n//点到点距离的平方\r\nfunction pointToPoint(point1, point2) {\r\n  return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1])\r\n}\r\n//点到线段的最短距离 平方\r\nfunction pointToLine(point, linePoint1, linePoint2) {\r\n  //直线向量\r\n  let lineVector = getVector(linePoint1, linePoint2)\r\n  //点积 \r\n  let m = dot(getVector(linePoint1, point), lineVector)\r\n  let n = dot(lineVector, lineVector)\r\n  if (m <= 0) {\r\n    return pointToPoint(linePoint1, point)\r\n  } else if (m >= n) {\r\n    return pointToPoint(linePoint2, point)\r\n  } else {\r\n    return (pointToPoint(linePoint1, point) - m * m / pointToPoint(linePoint2, linePoint1))\r\n  }\r\n}\r\n//点是否在图形内\r\nfunction pointInShape(point, shape) {\r\n  if (shape.hitType === 'Arc') {\r\n    if (pointToPoint(point, [shape.x, shape.y]) > shape.radius * shape.radius) {\r\n      return false\r\n    } else {\r\n      return true\r\n    }\r\n  } else {\r\n    let o = shape.pointO\r\n    let x = shape.pointX\r\n    let xy = shape.pointXY\r\n    let y = shape.pointY\r\n    let ox = getVector(o, x)\r\n    let op = getVector(o, point)\r\n    let xxy = getVector(x, xy)\r\n    let xp = getVector(x, point)\r\n    let xyy = getVector(xy, y)\r\n    let xyp = getVector(xy, point)\r\n    let yo = getVector(y, o)\r\n    let yp = getVector(y, point)\r\n\r\n    if (dot(ox, op) >= 0 && dot(xxy, xp) >= 0 && dot(xyy, xyp) >= 0 && dot(yo, yp) >= 0) {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n}\r\n\r\n//碰撞检测\r\nfunction isHit(element1, element2) {\r\n  // AABB元素的碰撞检测\r\n  if (element1.hitType === 'AABB' && element2.hitType === 'AABB') {\r\n    // AABB（未旋转矩形）的碰撞检测\r\n    let minX = Math.max(element1.pointO[0], element2.pointO[0])\r\n    let minY = Math.max(element1.pointO[1], element2.pointO[1])\r\n    let maxX = Math.min(element1.pointX[0], element2.pointX[0])\r\n    let maxY = Math.min(element1.pointY[1], element2.pointY[1])\r\n    if (minX < maxX && minY < maxY) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  //圆形和圆形\r\n  if (element1.hitType === 'Arc' && element2.hitType === 'Arc') {\r\n    let d = pointToPoint([element1.x, element1.y], [element2.x, element2.y])\r\n    let r = element1.radius * element1.radius + element2.radius * element2.radius\r\n    if (d > r) {\r\n      return false\r\n    } else {\r\n      return true\r\n    }\r\n  }\r\n\r\n  //圆形和矩形\r\n  if (((element1.hitType === 'AABB' || element1.hitType === 'Rect') && element2.hitType === 'Arc') || ((element2.hitType === 'AABB' || element2.hitType === 'Rect') && element1.hitType === 'Arc')) {\r\n    let arc\r\n    let rect\r\n    if (element1.hitType === 'Arc') {\r\n      arc = element1\r\n      rect = element2\r\n    } else {\r\n      arc = element2\r\n      rect = element1\r\n    }\r\n\r\n    //圆心坐标 p\r\n    let p = [arc.x, arc.y]\r\n    if (pointInShape(p, rect)) {\r\n      return true\r\n    } else {\r\n      let o = rect.pointO\r\n      let x = rect.pointX\r\n      let xy = rect.pointXY\r\n      let y = rect.pointY\r\n      let r = arc.radius * arc.radius\r\n\r\n      if (pointToLine(p, o, x) <= r || pointToLine(p, x, xy) <= r || pointToLine(p, xy, y) <= r || pointToLine(p, y, o) <= r) {\r\n        return true\r\n      } else {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  //矩形和矩形\r\n  if ((element1.hitType === 'Rect' || element2.hitType === 'Rect') && element1.hitType !== 'Arc' && element2.hitType !== 'Arc') {\r\n    let rect = element1\r\n    let shape = element2\r\n    for (let i = 0; i < 2; i++) {\r\n      let o = rect.pointO\r\n      let x = rect.pointX\r\n      let xy = rect.pointXY\r\n      let y = rect.pointY\r\n      if (pointInShape(o, shape) || pointInShape(x, shape) || pointInShape(xy, shape) || pointInShape(y, shape)) {\r\n        return true\r\n      } else {\r\n        rect = element2\r\n        shape = element1\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  //封印 BUG 的盒子！！！！！！！！！！\r\n  let bugBox = () => {\r\n    //基于分离轴原理的碰撞检测   不对，有bug\r\n    // 获取矩形的分离轴\r\n    let getRectAxis = (element) => {\r\n      if (element.hitType === 'AABB' || element.hitType === 'Rect') {\r\n        let vector = [getVector(element.pointO, element.pointX), getVector(element.pointO, element.pointY)]\r\n        let axis = []\r\n        for (let i = 0; i < vector.length; i++) {\r\n          let x = vector[i][0]\r\n          let y = vector[i][1]\r\n          if (x !== 0) {\r\n            axis.push([-y / x, 1])\r\n          } else if (y !== 0) {\r\n            axis.push([1, -x / y])\r\n          } else {\r\n            console.warn(element, '不存在含零向量的图形')\r\n          }\r\n        }\r\n        return axis\r\n      }\r\n    }\r\n    //获取圆形的分离轴\r\n    let getArcAxis = (element, arc) => {}\r\n    //判断点在分离轴上的投影，返回最大值和最小值\r\n    let getProj = (rect, axis) => {\r\n      let max = dot(getVector(rect.pointO, rect.pointX), axis)\r\n      let min = max\r\n\r\n      let arr = [dot(getVector(rect.pointX, rect.pointXY), axis), dot(getVector(rect.pointXY, rect.pointY), axis), dot(getVector(rect.pointY, rect.pointO), axis)]\r\n      console.log('pointToPoint', pointToPoint(rect.pointX, rect.pointXY));\r\n      console.log(rect);\r\n      console.log('p', rect.pointX, rect.pointXY);\r\n      console.log('v', getVector(rect.pointX, rect.pointXY));\r\n      console.log('d', dot(getVector(rect.pointX, rect.pointXY), axis));\r\n      for (let i = 0; i < 3; i++) {\r\n        if (arr[i] > max) {\r\n          max = arr[i]\r\n        }\r\n        if (arr[i] < min) {\r\n          min = arr[i]\r\n\r\n        }\r\n      }\r\n      return [min, max]\r\n    }\r\n    //如果是OBB矩形碰撞\r\n    if (element1.hitType === 'Rect' || element2.hitType === 'Rect' && element1.hitType !== 'Arc' && element2.hitType !== 'Arc') {\r\n      let axis = getRectAxis(element1)\r\n      for (let i = 0; i < axis.length; i++) {\r\n        let ele1 = getProj(element1, axis[i])\r\n        let ele2 = getProj(element2, axis[i])\r\n        if (ele1[1] > ele2[0] && ele2[1] > ele1[0]) {\r\n          return true\r\n        }\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n}\r\n\r\n//边界检测\r\nfunction isEdge(ele, width, height, pattern) {\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  getVector,\r\n  dot,\r\n  cross,\r\n  pointToPoint,\r\n  pointToLine,\r\n  pointInShape,\r\n  isHit,\r\n  isEdge\r\n});\n\n//# sourceURL=webpack:///./src/js/util.js?");

/***/ })

/******/ });